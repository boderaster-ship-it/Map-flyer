<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>FP-Globus – Offline, API-frei</title>
<style>
  :root {
    --ui-bg: rgba(0,0,0,.75);
    --ui-br: 12px;
    --ui-pad: 10px;
    --ui-gap: 10px;
    --ui-accent: #11c5ff;
    --ui-text: #e8f3ff;
    --ui-dim: #a9c2d8;
  }
  html, body { height: 100%; }
  body {
    margin: 0; background:#000; color:#fff; overflow:hidden; touch-action:none;
    font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  canvas { display:block; width:100vw; height:100vh; }
  /* HUD */
  #hud {
    position: fixed; top: env(safe-area-inset-top, 0); left: 0; right: 0;
    display:flex; justify-content:space-between; align-items:center;
    padding: 8px 10px; pointer-events:none;
  }
  #btnMenu, #btnHelp, #btnReset, #btnFS {
    pointer-events:auto; background:var(--ui-bg); color:var(--ui-text); border:1px solid #1e2a37;
    border-radius:999px; padding:8px 12px; margin-right:6px; user-select:none;
  }
  #btnRow { display:flex; align-items:center; gap:6px; }
  #infoLabel {
    background:var(--ui-bg); padding:6px 10px; border-radius:999px; color:var(--ui-dim);
    pointer-events:none; white-space:nowrap;
  }
  /* Menu Panel */
  #panel {
    position: fixed; top: calc(8px + env(safe-area-inset-top,0) + 44px);
    left: 8px; right: 8px; max-width: 520px; margin:auto; z-index:20;
    background:var(--ui-bg); border:1px solid #1e2a37; border-radius:var(--ui-br); padding:14px; display:none;
  }
  #panel.open { display:block; }
  .row { display:grid; grid-template-columns: 1fr auto; align-items:center; gap: var(--ui-gap); margin-bottom: var(--ui-gap); }
  .row > label { color: var(--ui-text); }
  .row input[type="range"] { width: 220px; }
  .row select, .row input[type="number"], .row input[type="checkbox"] { width: 150px; }
  #legend { color:var(--ui-dim); font-size:12px; margin-top:8px; }
  #footer {
    display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap;
    color:var(--ui-dim); font-size:12px; margin-top:6px;
  }
  /* On-screen joysticks for touch */
  .stick {
    position: fixed; bottom: 18vh; width: 120px; height: 120px; border-radius: 50%;
    border:1px solid #2b3b4f; background: radial-gradient(closest-side, rgba(17,197,255,.15), rgba(0,0,0,.6));
    display:none; z-index:15; pointer-events:none;
  }
  .knob {
    position:absolute; width:56px; height:56px; border-radius:50%; left:50%; top:50%;
    transform:translate(-50%, -50%); background:rgba(17,197,255,.35); border:1px solid #1e2a37;
  }
  #stickL { left: 20px; }
  #stickR { right: 20px; }
  /* Help overlay */
  #help {
    position:fixed; right:8px; top: calc(8px + env(safe-area-inset-top,0) + 44px);
    width:min(460px, 86vw); background:var(--ui-bg); border:1px solid #1e2a37;
    border-radius:var(--ui-br); padding:14px; display:none; z-index:20;
  }
  #help.open { display:block; }
  #help h3 { margin:0 0 8px 0; }
  #help p, #panel p { margin: 6px 0; }
  code { background:#0a1420; padding:2px 6px; border-radius:6px; }
  /* FPS crosshair */
  #cross {
    position:fixed; left:50%; top:50%; width:16px; height:16px; transform:translate(-50%,-50%);
    pointer-events:none; opacity:.6; z-index:5;
  }
  #cross:before, #cross:after {
    content:""; position:absolute; background:#9ddcff;
  }
  #cross:before { left:7px; top:0; width:2px; height:16px; }
  #cross:after  { top:7px; left:0; width:16px; height:2px; }
  /* Minimal loading badge */
  #boot {
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    padding:10px 14px; border-radius:999px; background:var(--ui-bg); border:1px solid #1e2a37; color:#b3e7ff;
    animation: fadeout 0.8s ease 1.2s forwards;
  }
  @keyframes fadeout { to { opacity:0; visibility:hidden; } }
</style>
</head>
<body>
<canvas id="gl"></canvas>

<div id="hud">
  <div id="btnRow">
    <button id="btnMenu">☰ Menü</button>
    <button id="btnHelp">❓ Hilfe</button>
    <button id="btnReset">⟲ Reset</button>
    <button id="btnFS">⛶ Vollbild</button>
  </div>
  <div id="infoLabel">FPS: <span id="fps">–</span> · Höhe: <span id="hgt">1.7</span> m · Modus: <span id="modeLabel">Gehen</span></div>
</div>

<div id="panel">
  <div class="row">
    <label for="speed">Schritt-/Fahr-Geschwindigkeit (m/s)</label>
    <input id="speed" type="range" min="0.2" max="90" step="0.1" value="1.6">
  </div>
  <div class="row">
    <label for="mode">Bewegungsmodus</label>
    <select id="mode">
      <option value="walk" selected>Gehen (~1.6 m/s)</option>
      <option value="jog">Joggen (~3 m/s)</option>
      <option value="car">Auto (~13.9 m/s = 50 km/h)</option>
    </select>
  </div>
  <div class="row">
    <label for="eye">Augenhöhe (m)</label>
    <input id="eye" type="range" min="1.2" max="2.4" step="0.01" value="1.7">
  </div>
  <div class="row">
    <label for="quality">Grafikqualität (Segmente)</label>
    <select id="quality">
      <option value="48">Niedrig (48×48)</option>
      <option value="64" selected>Mittel (64×64)</option>
      <option value="90">Hoch (90×90)</option>
    </select>
  </div>
  <div class="row">
    <label for="fov">Sichtfeld (°)</label>
    <input id="fov" type="range" min="50" max="100" step="1" value="70">
  </div>
  <div class="row">
    <label for="autoscale">Auto-Skalierung (wie „Auto-Größe“)</label>
    <input id="autoscale" type="checkbox" checked>
  </div>
  <div class="row">
    <label for="invertY">Blick Y invertieren</label>
    <input id="invertY" type="checkbox">
  </div>
  <div id="legend">Hinweis: API-frei. Die Textur wird prozedural aus frei nutzbaren Kontinent-Umrissen generiert; nicht vorhandene Bereiche = Wasser. Läuft mobil (iPhone) inkl. Touch-Joysticks.</div>
  <div id="footer">
    <div>⟵ <code>WASD</code> / <code>←↑→↓</code> / linke Steuerkugel: bewegen · rechte Steuerkugel: Blick</div>
    <div><code>Tab</code>/<code>Menü</code> öffnet dieses Panel · Klick auf die Szene = Mauslook</div>
  </div>
</div>

<div id="help">
  <h3>Steuerung & Tipps</h3>
  <p><b>Desktop:</b> <code>WASD</code> bewegen, Maus zum Umsehen (Klick für Pointer-Lock), <code>Shift</code> = temporärer Sprint. <code>R</code> = Reset, <code>M</code> = Menü.</p>
  <p><b>iPhone:</b> linke Kugel = bewegen, rechte = umsehen. Menü über „☰“.</p>
  <p><b>Auto-Skalierung:</b> passt die Geschwindigkeit an das Sichtfeld an – ähnlich dem Gefühl, „in Google Maps mit Auto-Maßstab“ zu fahren/zoomen.</p>
  <p>Die Kamera bleibt in realistischer Höhe über der Erdoberfläche und läuft tangential über die Kugel.</p>
</div>

<div id="stickL" class="stick"><div class="knob"></div></div>
<div id="stickR" class="stick"><div class="knob"></div></div>

<div id="cross" aria-hidden="true"></div>
<div id="boot">Starte Globus…</div>

<script>
/* ------------------ Minimal Vec/Mat utils (no libs) ------------------ */
const EPS = 1e-6;
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function rad(d){return d*Math.PI/180;} function deg(r){return r*180/Math.PI;}
function vec3(x=0,y=0,z=0){return new Float32Array([x,y,z]);}
function add(a,b){return vec3(a[0]+b[0],a[1]+b[1],a[2]+b[2]);}
function sub(a,b){return vec3(a[0]-b[0],a[1]-b[1],a[2]-b[2]);}
function mul(a,s){return vec3(a[0]*s,a[1]*s,a[2]*s);}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function cross(a,b){return vec3(a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]);}
function len(a){return Math.hypot(a[0],a[1],a[2]);}
function norm(a){const L=len(a)||1;return vec3(a[0]/L,a[1]/L,a[2]/L);}
function mat4(){return new Float32Array(16);}
function ident(m){m.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return m;}
function perspective(out, fovy, aspect, near, far){
  const f = 1/Math.tan(fovy/2), nf = 1/(near-far);
  out.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]); return out;
}
function lookAt(out, eye, center, up){
  let z = norm(sub(eye, center));
  let x = norm(cross(up, z));
  let y = cross(z, x);
  out.set([ x[0], y[0], z[0], 0,
            x[1], y[1], z[1], 0,
            x[2], y[2], z[2], 0,
           -dot(x,eye), -dot(y,eye), -dot(z,eye), 1 ]);
  return out;
}
function mul4(out,a,b){
  const o = new Float32Array(16);
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){
    o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];
  }
  out.set(o); return out;
}
function rotateAroundAxis(v, axis, angle){
  // Rodrigues
  const k = norm(axis), c=Math.cos(angle), s=Math.sin(angle);
  const kv = cross(k,v);
  const kk = dot(k,v);
  return add(add(mul(v,c), mul(kv,s)), mul(k, kk*(1-c)));
}

/* ------------------ Procedural "satellite-like" texture ------------------ */
/* API-frei: wir malen grobe Kontinente + Farbzonen (Wald/Wüste) direkt ins Canvas */
function makeEarthTexture(w=1024,h=512){
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  const ctx=c.getContext('2d');
  // Ozean
  const oceanGrad = ctx.createLinearGradient(0,0,0,h);
  oceanGrad.addColorStop(0, '#0a2a43'); oceanGrad.addColorStop(.5, '#0c3558'); oceanGrad.addColorStop(1,'#0a2740');
  ctx.fillStyle=oceanGrad; ctx.fillRect(0,0,w,h);

  const toXY = (lon, lat)=>[( (lon+180)/360 )*w, ( (90-lat)/180 )*h];
  function drawPoly(points, fill){
    ctx.beginPath();
    points.forEach((p,i)=>{ const [x,y]=toXY(p[0],p[1]); i?ctx.lineTo(x,y):ctx.moveTo(x,y); });
    ctx.closePath(); ctx.fillStyle=fill; ctx.fill();
  }
  // Zonenfarbe nach Breite
  const zoneColor = (lat)=> {
    const a = Math.abs(lat);
    if(a < 10) return '#1a5f2b';      // Äquator: Regenwald
    if(a < 25) return '#7a6a2f';      // Subtropen: Wüste/Busch
    if(a < 45) return '#2f6b34';      // Gemäßigt
    if(a < 65) return '#3c6f4a';      // Boreal
    return '#bcd7e1';                 // Tundra/Eisnähe
  };
  // Kontinente (sehr grob) – frei skizziert
  const AFRICA = [[-17,32],[4,36],[34,31],[51,11],[44,2],[43,-10],[40,-26],[29,-34],[13,-28],[8,-18],[-1,4],[-5,6],[-17,21]];
  const EURASIA = [[-10,36],[6,44],[20,70],[50,70],[100,78],[170,65],[135,50],[122,24],[105,5],[77,8],[66,23],[56,18],[44,30],[35,39],[27,41],[12,43],[-7,43],[-10,36]];
  const NA = [[-168,72],[-150,72],[-130,55],[-98,50],[-83,31],[-97,23],[-110,23],[-118,33],[-125,49],[-140,58],[-160,67],[-168,72]];
  const SA = [[-81,12],[-65,9],[-35,5],[-34,-17],[-50,-33],[-55,-55],[-71,-55],[-77,-40],[-78,-14],[-81,12]];
  const AUS = [[112,-11],[154,-10],[155,-28],[147,-38],[130,-40],[117,-34],[113,-23],[112,-11]];
  const GREEN = [[-60,83],[-20,83],[-20,60],[-60,60],[-60,83]];
  const ARABIA = [[34,31],[45,31],[56,26],[57,18],[50,15],[44,22],[43,30],[34,31]];
  const INDIA = [[68,23],[78,30],[88,26],[92,22],[90,19],[84,12],[80,9],[77,8],[73,15],[68,23]];

  function fillPoly(poly){
    // Mittelbreite
    const m = poly.reduce((a,p)=>a+p[1],0)/poly.length;
    drawPoly(poly, zoneColor(m));
  }
  [AFRICA, EURASIA, NA, SA, AUS, GREEN, ARABIA, INDIA].forEach(fillPoly);

  // Zusatz: Japan, UK, Neuseeland, Madagaskar, Kuba – als Kreise/Ellipsen
  function dotLand(lon, lat, rxDeg, ryDeg, col){
    const [cx,cy]=toXY(lon,lat);
    ctx.save(); ctx.beginPath();
    ctx.ellipse(cx,cy, (rxDeg/360)*w, (ryDeg/180)*h, 0, 0, Math.PI*2);
    ctx.fillStyle = col ?? zoneColor(lat);
    ctx.fill(); ctx.restore();
  }
  dotLand(139.7,35.6,2.0,1.2); // Japan
  dotLand(-3.5,54.3,2.0,1.0);  // UK
  dotLand(46.7,-19,2.5,1.2);   // Madagaskar
  dotLand(174,-41,2.5,1.2);    // Neuseeland
  dotLand(-79.4,21.5,1.6,0.8); // Kuba

  // Eisflächen
  ctx.fillStyle = '#e8f6ff';
  ctx.beginPath(); ctx.rect(0, 0, w, h*0.06); ctx.fill(); // Arktis Gürtel
  ctx.beginPath(); ctx.rect(0, h*0.85, w, h*0.15); ctx.fill(); // Antarktis

  // Leichte Wolken-/Textur-Noise
  const n = ctx.createImageData(w,h);
  const buf = n.data;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i=(y*w+x)*4;
      // Sample aktuelle Pixel-Farbe
      const p=ctx.getImageData(x,y,1,1).data;
      // Hauch Noise
      const r = (Math.sin((x*12.9898+y*78.233))*43758.5453)%1; // pseudo
      const f = 1 + (r-0.5)*0.06;
      buf[i]=clamp(p[0]*f,0,255); buf[i+1]=clamp(p[1]*f,0,255); buf[i+2]=clamp(p[2]*f,0,255); buf[i+3]=255;
    }
  }
  ctx.putImageData(n,0,0);
  // Dezente Küsten-Aufhellung
  ctx.globalCompositeOperation='overlay';
  const coast = ctx.createLinearGradient(0,0,w,0);
  coast.addColorStop(0,'rgba(255,255,255,.04)');
  coast.addColorStop(1,'rgba(255,255,255,.04)');
  ctx.fillStyle=coast; ctx.fillRect(0,0,w,h);
  ctx.globalCompositeOperation='source-over';

  return c;
}

/* ------------------ WebGL setup ------------------ */
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl', { antialias:true, alpha:false, stencil:false, depth:true, powerPreference:'high-performance', preserveDrawingBuffer:false });
if(!gl){ alert('WebGL wird benötigt.'); }
const dpr = Math.min(window.devicePixelRatio || 1, 2);

function resize(){
  const w = Math.floor(window.innerWidth * dpr), h = Math.floor(window.innerHeight * dpr);
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h; gl.viewport(0,0,w,h);
  }
}
window.addEventListener('resize', resize, {passive:true});

/* Shaders */
const VS = `
attribute vec3 aPos;
attribute vec3 aNormal;
attribute vec2 aUV;
uniform mat4 uView, uProj, uModel;
varying vec3 vN;
varying vec3 vP;
varying vec2 vUV;
void main(){
  vec4 wp = uModel * vec4(aPos,1.0);
  vN = mat3(uModel) * aNormal;
  vP = wp.xyz;
  vUV = aUV;
  gl_Position = uProj * uView * wp;
}`;
const FS = `
precision mediump float;
varying vec3 vN;
varying vec3 vP;
varying vec2 vUV;
uniform sampler2D uTex;
uniform vec3 uLightDir;
uniform vec3 uWater;
uniform float uUseTex; // 1.0 = Textur, 0.0 = nur Wasser
void main(){
  vec3 N = normalize(vN);
  float lam = max(dot(N, normalize(uLightDir)), 0.0);
  vec3 col = texture2D(uTex, vec2(vUV.x, 1.0 - vUV.y)).rgb;
  // Erkennen „Wasser“ (blau-dominiert) – falls Textur aktiv
  float isWater = step(0.0, uUseTex) * float(col.b > col.r && col.b > col.g) + (1.0 - step(0.0, uUseTex));
  vec3 base = mix(col, uWater, isWater);
  // Atmosphäre/Schattierung
  float amb = 0.45;
  vec3 lightCol = vec3(1.0, 0.98, 0.95);
  vec3 shaded = base*(amb + lam*0.55) + lightCol*pow(max(dot(reflect(-normalize(uLightDir), N), -normalize(vP)),0.0), 24.0)*0.05;
  gl_FragColor = vec4(shaded, 1.0);
}`;
function compile(type, src){
  const s = gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); throw new Error('Shader compile failed');}
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, VS));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FS));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ throw new Error(gl.getProgramInfoLog(prog));}
gl.useProgram(prog);

/* Attributes & uniforms */
const attrib = {
  pos: gl.getAttribLocation(prog,'aPos'),
  nrm: gl.getAttribLocation(prog,'aNormal'),
  uv:  gl.getAttribLocation(prog,'aUV'),
};
const uni = {
  view: gl.getUniformLocation(prog,'uView'),
  proj: gl.getUniformLocation(prog,'uProj'),
  model: gl.getUniformLocation(prog,'uModel'),
  tex: gl.getUniformLocation(prog,'uTex'),
  lightDir: gl.getUniformLocation(prog,'uLightDir'),
  water: gl.getUniformLocation(prog,'uWater'),
  useTex: gl.getUniformLocation(prog,'uUseTex'),
};

/* Sphere mesh (<= 90×90 to stay within Uint16 limit safely) */
function makeSphere(latSeg=64, lonSeg=64, radius=1){
  // clamp to keep indices under 65k
  latSeg = Math.max(8, Math.min(90, latSeg|0));
  lonSeg = Math.max(8, Math.min(90, lonSeg|0));
  const verts=[], nrms=[], uvs=[];
  for(let i=0;i<=latSeg;i++){
    const v = i/latSeg, phi = v*Math.PI; // 0..PI
    for(let j=0;j<=lonSeg;j++){
      const u = j/lonSeg, th = (u*2.0-1.0)*Math.PI; // -PI..PI
      const x = Math.sin(phi)*Math.cos(th);
      const y = Math.cos(phi);
      const z = Math.sin(phi)*Math.sin(th);
      verts.push(x*radius, y*radius, z*radius);
      nrms.push(x,y,z);
      uvs.push(u, v);
    }
  }
  const idx=[];
  const row = lonSeg+1;
  for(let i=0;i<latSeg;i++){
    for(let j=0;j<lonSeg;j++){
      const a = i*row + j, b = a + row, c = b + 1, d = a + 1;
      idx.push(a,b,d, b,c,d);
    }
  }
  const vao = gl.createVertexArray ? gl.createVertexArray() : null;
  if(gl.createVertexArray) gl.bindVertexArray(vao);
  const vboPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attrib.pos); gl.vertexAttribPointer(attrib.pos,3,gl.FLOAT,false,0,0);
  const vboNrm = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboNrm);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nrms), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attrib.nrm); gl.vertexAttribPointer(attrib.nrm,3,gl.FLOAT,false,0,0);
  const vboUV  = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboUV);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attrib.uv); gl.vertexAttribPointer(attrib.uv,2,gl.FLOAT,false,0,0);
  const ebo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
  const indexArr = (Math.max(...idx) > 65535) ? new Uint32Array(idx) : new Uint16Array(idx);
  if(indexArr instanceof Uint32Array){
    const ext = gl.getExtension('OES_element_index_uint'); if(!ext){ console.warn('OES_element_index_uint fehlt, reduziere Segmente.'); }
  }
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArr, gl.STATIC_DRAW);
  if(gl.createVertexArray) gl.bindVertexArray(null);

  return { vao, vboPos, vboNrm, vboUV, ebo, count: idx.length };
}

/* Texture from procedural canvas */
const earthCanvas = makeEarthTexture(1024,512);
let texEarth = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texEarth);
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, earthCanvas);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.generateMipmap(gl.TEXTURE_2D);

gl.clearColor(0,0,0,1);
gl.enable(gl.DEPTH_TEST);

/* ------------------ Camera & movement ------------------ */
const R = 6371000.0; // Erd-Radius in m
let lat = rad(48.9); // Start: ca. Deutschland
let lon = rad(8.7);
let yaw = 0.0, pitch = 0.0; // Blick
let eyeHeight = 1.7; // in m
let speed = 1.6; // m/s
let autoscale = true;
let invertY = false;
const sunDir = norm(vec3(1,0.3,0.2));

const keys = {};
window.addEventListener('keydown', e=>{
  if(e.code==='KeyM' || e.code==='Tab'){ e.preventDefault(); togglePanel(); }
  if(e.code==='KeyR'){ resetPose(); }
  keys[e.code]=true;
});
window.addEventListener('keyup', e=>{ keys[e.code]=false; });

function resetPose(){
  lat = rad(48.9); lon=rad(8.7); yaw=0; pitch=0;
}
function clampPitch(){ const max=rad(85); pitch = clamp(pitch, -max, max); }

/* Sphärische Navigation: Distanz (m) + Peilung (rad) -> neue lat/lon */
function moveOnSphere(lat0, lon0, bearing, dist){
  const d = dist / R;
  const sinLat0 = Math.sin(lat0), cosLat0 = Math.cos(lat0);
  const sinD = Math.sin(d), cosD = Math.cos(d);
  const sinLat1 = sinLat0 * cosD + cosLat0 * sinD * Math.cos(bearing);
  const lat1 = Math.asin( clamp(sinLat1, -1, 1) );
  const y = Math.sin(bearing) * sinD * cosLat0;
  const x = cosD - sinLat0 * sinLat1;
  let lon1 = lon0 + Math.atan2(y, x);
  // Wrap auf -PI..PI
  lon1 = ((lon1 + Math.PI) % (2*Math.PI) + 2*Math.PI) % (2*Math.PI) - Math.PI;
  return [lat1, lon1];
}

/* ------------------ Input: mouse / touch ------------------ */
let pointerLocked = false, lookSensitivity = 0.0025;
canvas.addEventListener('click', ()=>{
  if(document.pointerLockElement) return;
  canvas.requestPointerLock?.();
});
document.addEventListener('pointerlockchange', ()=>{ pointerLocked = !!document.pointerLockElement; });
document.addEventListener('mousemove', (e)=>{
  if(!pointerLocked) return;
  yaw -= e.movementX * lookSensitivity;
  const signY = invertY ? 1 : -1;
  pitch += signY * e.movementY * lookSensitivity;
  clampPitch();
});

/* Touch joysticks */
const stickL = document.getElementById('stickL');
const stickR = document.getElementById('stickR');
const knobL = stickL.querySelector('.knob');
const knobR = stickR.querySelector('.knob');
let touchMove = {x:0, y:0}; // -1..1
let touchLook = {x:0, y:0};
let touchIdL = null, touchIdR = null;
const stickRadius = 52;
function showStick(el, x, y){ el.style.display='block'; el.style.left = (x-60)+'px'; el.style.top=(y-60)+'px'; }
function moveKnob(knob, dx, dy){
  const L = Math.hypot(dx,dy);
  const m = Math.min(L, stickRadius);
  const nx = (dx/L||0)*m, ny=(dy/L||0)*m;
  knob.style.transform = `translate(${nx}px, ${ny}px)`;
}
function endStick(el, knob){ el.style.display='none'; knob.style.transform='translate(-50%,-50%)'; }

window.addEventListener('touchstart', (e)=>{
  for(const t of e.changedTouches){
    // Linke Hälfte -> Move, rechte -> Look
    if(t.clientX < window.innerWidth*0.5 && touchIdL===null){
      touchIdL = t.identifier; touchMove={x:0,y:0};
      showStick(stickL, t.clientX, t.clientY);
      stickL.dataset.cx = t.clientX; stickL.dataset.cy = t.clientY;
    } else if (touchIdR===null) {
      touchIdR = t.identifier; touchLook={x:0,y:0};
      showStick(stickR, t.clientX, t.clientY);
      stickR.dataset.cx = t.clientX; stickR.dataset.cy = t.clientY;
    }
  }
},{passive:false});

window.addEventListener('touchmove', (e)=>{
  for(const t of e.changedTouches){
    if(t.identifier===touchIdL){
      const dx = t.clientX - (+stickL.dataset.cx), dy = t.clientY - (+stickL.dataset.cy);
      const nx = clamp(dx/stickRadius, -1, 1), ny = clamp(dy/stickRadius, -1, 1);
      touchMove = {x:nx, y:ny};
      moveKnob(knobL, dx, dy);
    } else if (t.identifier===touchIdR){
      const dx = t.clientX - (+stickR.dataset.cx), dy = t.clientY - (+stickR.dataset.cy);
      const nx = clamp(dx/stickRadius, -1, 1), ny = clamp(dy/stickRadius, -1, 1);
      touchLook = {x:nx, y:ny};
      moveKnob(knobR, dx, dy);
    }
  }
},{passive:false});

window.addEventListener('touchend', (e)=>{
  for(const t of e.changedTouches){
    if(t.identifier===touchIdL){ touchIdL=null; touchMove={x:0,y:0}; endStick(stickL, knobL); }
    if(t.identifier===touchIdR){ touchIdR=null; touchLook={x:0,y:0}; endStick(stickR, knobR); }
  }
},{passive:false});

/* ------------------ UI controls ------------------ */
const panel = document.getElementById('panel');
const help = document.getElementById('help');
function togglePanel(){ panel.classList.toggle('open'); }
function toggleHelp(){ help.classList.toggle('open'); }
document.getElementById('btnMenu').onclick = togglePanel;
document.getElementById('btnHelp').onclick = toggleHelp;
document.getElementById('btnReset').onclick = ()=>{ resetPose(); };
document.getElementById('btnFS').onclick = ()=>{
  if(document.fullscreenElement){ document.exitFullscreen(); }
  else { document.documentElement.requestFullscreen?.(); }
};
const fpsLabel = document.getElementById('fps');
const hgtLabel = document.getElementById('hgt');
const modeSel = document.getElementById('mode');
const modeLabel = document.getElementById('modeLabel');

const speedSlider = document.getElementById('speed');
const eyeSlider = document.getElementById('eye');
const fovSlider = document.getElementById('fov');
const qSel = document.getElementById('quality');
const autoChk = document.getElementById('autoscale');
const invYChk = document.getElementById('invertY');

speedSlider.oninput = ()=>{ speed = +speedSlider.value; syncModeLabel(); };
eyeSlider.oninput = ()=>{ eyeHeight = +eyeSlider.value; hgtLabel.textContent = eyeHeight.toFixed(1); };
fovSlider.oninput = ()=>{ camera.fov = +fovSlider.value; camera.updateProj(); };
qSel.onchange = ()=>{ const s = +qSel.value; reMesh(s,s); };
autoChk.onchange = ()=>{ autoscale = autoChk.checked; };
invYChk.onchange = ()=>{ invertY = invYChk.checked; };

modeSel.onchange = ()=>{
  if(modeSel.value==='walk') speed = 1.6;
  if(modeSel.value==='jog')  speed = 3.0;
  if(modeSel.value==='car')  speed = 13.8889;
  speedSlider.value = speed.toFixed(1);
  syncModeLabel();
};
function syncModeLabel(){
  const m = modeSel.value;
  const nice = m==='walk'?'Gehen':(m==='jog'?'Joggen':'Auto');
  modeLabel.textContent = nice;
}

let mesh = makeSphere(64,64,1.0);
function reMesh(ls, ts){
  // Clean old buffers
  if(mesh){
    gl.deleteBuffer(mesh.vboPos); gl.deleteBuffer(mesh.vboNrm); gl.deleteBuffer(mesh.vboUV);
    gl.deleteBuffer(mesh.ebo); if(mesh.vao && gl.deleteVertexArray) gl.deleteVertexArray(mesh.vao);
  }
  mesh = makeSphere(ls,ts,1.0);
}

/* ------------------ Camera ------------------ */
const camera = {
  fov: 70,
  proj: mat4(),
  view: mat4(),
  model: mat4(),
  updateProj(){ perspective(this.proj, rad(this.fov), canvas.width/Math.max(1,canvas.height), 0.1, 5000.0); }
};
ident(camera.model);
camera.updateProj();

/* ------------------ Render loop ------------------ */
let last=performance.now(), acc=0, frames=0, lastFPS=performance.now();
resize();

function render(now){
  const dt = Math.min(0.05, (now-last)/1000); last = now;
  // Inputs
  const run = keys['ShiftLeft']||keys['ShiftRight'] ? 1.7 : 1.0;
  let vF = 0, vS = 0;
  if(keys['KeyW']||keys['ArrowUp']) vF -= 1;
  if(keys['KeyS']||keys['ArrowDown']) vF += 1;
  if(keys['KeyA']||keys['ArrowLeft']) vS -= 1;
  if(keys['KeyD']||keys['ArrowRight']) vS += 1;
  // Touch look
  const lookX = touchLook.x, lookY = touchLook.y;
  if(Math.abs(lookX)>0.01 || Math.abs(lookY)>0.01){
    const k = 1.1; // touch sensitivity
    yaw -= lookX * lookSensitivity*38*k;
    const sy = invertY ? -1 : 1;
    pitch += sy * lookY * lookSensitivity*38*k;
    clampPitch();
  }
  // Touch move
  vS += touchMove.x; vF += touchMove.y;

  // Local frame at current lat/lon
  const up = vec3(Math.cos(lat)*Math.cos(lon), Math.sin(lat), Math.cos(lat)*Math.sin(lon));
  const northPole = vec3(0,1,0);
  let east = cross(northPole, up);
  if(len(east)<EPS) east = vec3(1,0,0);
  east = norm(east);
  let north = norm(cross(east, up));

  // Look direction from yaw/pitch around local frame
  let forward = north;
  forward = rotateAroundAxis(forward, up, yaw);
  const right = norm(cross(forward, up));
  forward = norm( rotateAroundAxis(forward, right, pitch) );

  // Auto-Scale speed like Google Maps „Auto-Größe“ Gefühl
  let v = speed * run;
  if(autoscale){
    // Simple rule: scale with tan(FOV/2) -> subjektives Geschwindigkeitsgefühl beim Zoom
    const scale = Math.tan(rad(camera.fov)/2)/Math.tan(rad(70)/2);
    v *= clamp(scale, 0.7, 1.6);
  }

  // Move along sphere
  if(Math.abs(vF)>0.001 || Math.abs(vS)>0.001){
    const moveDir = norm( add( mul(forward, -vF), mul(right, vS) ) );
    // Bearing rel. to local north
    const bearing = Math.atan2( dot(moveDir, east), dot(moveDir, north) ); // +east, +north
    const dist = v * dt;
    const res = moveOnSphere(lat, lon, bearing, dist);
    lat = res[0]; lon = res[1];
  }

  // Camera eye / center
  const eye = mul(up, (R + eyeHeight)/R); // Skalieren auf Radius 1 + (H/R)
  const center = add(eye, mul(forward, 0.3)); // Fokus etwas vor die Nase
  lookAt(camera.view, eye, center, up);
  camera.updateProj();

  // Draw
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  gl.useProgram(prog);
  if(gl.bindVertexArray && mesh.vao){ gl.bindVertexArray(mesh.vao);
  } else {
    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vboPos); gl.enableVertexAttribArray(attrib.pos); gl.vertexAttribPointer(attrib.pos,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vboNrm); gl.enableVertexAttribArray(attrib.nrm); gl.vertexAttribPointer(attrib.nrm,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vboUV); gl.enableVertexAttribArray(attrib.uv); gl.vertexAttribPointer(attrib.uv,2,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ebo);
  }
  gl.uniformMatrix4fv(uni.view,false,camera.view);
  gl.uniformMatrix4fv(uni.proj,false,camera.proj);
  gl.uniformMatrix4fv(uni.model,false,camera.model);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texEarth);
  gl.uniform1i(uni.tex, 0);
  gl.uniform3f(uni.lightDir, sunDir[0], sunDir[1], sunDir[2]);
  gl.uniform3f(uni.water, 0.05, 0.21, 0.35);
  gl.uniform1f(uni.useTex, 1.0); // wir haben immer eine Textur
  gl.drawElements(gl.TRIANGLES, mesh.count, (Math.max(mesh.count,0)>65535)?gl.UNSIGNED_INT:gl.UNSIGNED_SHORT, 0);

  // FPS stats
  frames++; acc += dt;
  if(now - lastFPS > 500){
    const fps = Math.round(frames*1000/(now-lastFPS));
    fpsLabel.textContent = String(fps);
    frames=0; lastFPS = now;
  }
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* ------------------ Boot + initial UI sync ------------------ */
syncModeLabel();
hgtLabel.textContent = eyeHeight.toFixed(1);
setTimeout(()=>document.getElementById('boot').remove(), 2000);

/* Accessibility shortcuts for iOS toolbar avoidance */
window.addEventListener('orientationchange', ()=>{ setTimeout(resize, 250); }, {passive:true});
</script>
</body>
</html>
